[{"id":0,"href":"/goMESA/docs/introduction/","title":"Introduction","section":"Docs","content":" 1.1. Overview # goMESA is an educational Command and Control (C2) framework designed to demonstrate how legitimate network protocols can be repurposed for covert communications. Specifically, it utilizes the Network Time Protocol (NTP) as its transport mechanism, embedding command and control traffic within seemingly normal time synchronization packets.\nIt is based on mesa, with the following notable changes:\nEntire application is rewritten in Golang + integration of concurrency SQLite instead of MySQL as a simpler option Vue.js Web Client UI Docker support AES-256-GCM as a more secure encryption method Comprehensive documentation 1.2. Core Components # goMESA consists of three main components:\nC2 Server: Runs on an operator-controlled system. It acts as a fully functional NTP server (responding to legitimate time requests) while also listening for and managing connections from goMESA agents. It provides an interface for the operator to interact with agents and stores agent information and command history in a database. Agent: Runs on target systems (Windows, Linux, macOS). It mimics a standard NTP client, configuring the host system to use the C2 server for time synchronization. Covertly, it uses this NTP communication channel to receive commands, execute them, and send back results. Client UI: A Vue.js client establishes a persistent WebSocket connection to the goMESA server (or a dedicated web API layer), allowing for real-time, bidirectional communication. By operating under the guise of essential NTP traffic, goMESA aims to evade detection by network security monitoring tools that may not closely inspect UDP port 123 traffic.\n1.3. Features # NTP-Based Covert Channel: Uses UDP port 123 for all C2 communications. Functional NTP Server: The C2 server provides legitimate time synchronization, enhancing plausible deniability. Cross-Platform Agents: Supports Windows, Linux, and macOS target systems. Database Backend: Supports SQLite (default, portable). Agent Grouping: Manage agents efficiently by OS or custom service tags. Encryption: Offers basic XOR obfuscation and stronger AES-256-GCM encryption for payloads. Packet-Level Operations: Utilizes raw packet capture (libpcap/gopacket) for stealthy agent operation. Containerization Support: Docker and Docker Compose files available for easier deployment. NEXT\n"},{"id":1,"href":"/goMESA/docs/theory_concepts/","title":"Theory and Concepts","section":"Docs","content":" 2.1. NTP as a Covert Channel # NTP as transport protocol leverages several characteristics that make it interesting for covert communication.\n2.1.1. Why NTP Works # Ubiquity \u0026amp; Necessity: NTP is a fundamental internet protocol required by nearly all systems for time synchronization. It\u0026rsquo;s essential for logging, security mechanisms (like Kerberos), financial transactions, and more. Default Firewall Allowance: Due to its necessity, NTP traffic (UDP port 123) is almost universally permitted through firewalls. Limited Inspection: Unlike HTTP/S or DNS, NTP traffic is rarely subjected to deep packet inspection or significant scrutiny by security appliances. UDP Protocol: Being UDP-based, NTP is connectionless, simplifying the process of crafting and injecting custom packets without session establishment overhead. Regular Timing Patterns: Legitimate NTP clients communicate periodically, making the regular beaconing of C2 agents appear less suspicious than protocols with constant connections. Bidirectional Nature: The standard request-response pattern of NTP naturally facilitates two-way C2 communication. 2.1.2. Legitimate Cover \u0026amp; Plausible Deniability # A key aspect of goMESA\u0026rsquo;s design is that the C2 server functions as a real NTP server. It correctly processes and responds to time requests from standard NTP clients. This dual functionality provides plausible deniability; even if the server\u0026rsquo;s traffic is inspected, it appears to be legitimately serving time. The C2 communications are hidden within what looks like standard protocol interactions.\n2.2. Background on NTP # Understanding NTP\u0026rsquo;s normal operation highlights how goMESA exploits it.\n2.2.1. The Foundation of Internet Timekeeping # Developed by David Mills in 1985, NTP synchronizes clocks across computer networks. It uses a hierarchical system of \u0026ldquo;strata,\u0026rdquo; where Stratum 0 are high-precision sources (atomic clocks, GPS), Stratum 1 servers sync directly to Stratum 0, and so on. Most devices sync to servers several strata removed.\n2.2.2. Protocol Characteristics (UDP, Port 123) # NTP operates at the Application Layer but uses UDP (typically port 123) as its transport protocol. UDP\u0026rsquo;s connectionless nature is suitable for time synchronization where timeliness is valued over guaranteed delivery.\n2.2.3. Packet Structure \u0026amp; Timestamps # A standard NTP packet is 48 bytes long. Key fields include:\nLeap Indicator, Version Number, Mode (Client/Server/etc.) Stratum level Poll Interval, Precision Root Delay, Root Dispersion Reference ID Four 64-bit timestamps (Reference, Originate, Receive, Transmit) used for calculating clock offset and round-trip delay. 2.2.4. Operational Patterns # Clients poll servers periodically. The interval is adaptive, often starting frequently (e.g., 64s) and increasing (e.g., 1024s) as the clock stabilizes. Clients use the four timestamps in the request/response cycle to calculate offset and delay, gradually \u0026ldquo;slewing\u0026rdquo; their clock to match the server\u0026rsquo;s time, avoiding disruptive jumps.\n2.3. Raw Network Access Concepts (libpcap/gopacket) # goMESA agents use raw network access for stealth and control, typically via libraries like libpcap (or its Windows equivalent Npcap) accessed through Go bindings like gopacket.\n2.3.1. Introduction to Packet Capture # Standard applications use high-level socket APIs. Packet capture libraries bypass these, tapping directly into the network interface data stream (typically at the Data Link Layer). This provides access to complete, unmodified network packets, including all headers.\n2.3.2. Technical Foundation (Architecture, Filtering) # libpcap uses kernel-level mechanisms (e.g., BPF, AF_PACKET) to intercept packet copies. Crucially, it allows efficient kernel-level filtering (using BPF syntax like \u0026quot;udp and port 123\u0026quot;) so only relevant packets are passed to the user-space application, minimizing overhead. Captured packets are buffered in the kernel before being delivered to the application via the libpcap API.\n2.3.3. Benefits and Limitations # Benefits: Complete visibility, protocol independence, passive observation, custom packet crafting (injection), cross-platform API. Limitations: Requires root/admin privileges, performance overhead (kernel-user copy), complexity (protocol knowledge needed), potential for packet loss under heavy load, security implications of raw access. 2.3.4. Comparison to Standard Socket Programming # When a typical application uses sockets (like TCP or UDP sockets), it interacts primarily at the Transport Layer (L4) or slightly above. The operating system\u0026rsquo;s networking stack handles the processing for Layers 2 (Data Link), 3 (Network), and 4 (Transport). It strips away the headers from these lower layers and delivers only the application-level payload (Layer 7 data) to the application via the socket interface. Packet capture bypasses the operating system\u0026rsquo;s standard processing path that would normally handle layers 2, 3, and 4 and deliver only the L7 payload to an application via a socket. Instead, it gives the capturing application the raw data much lower down the stack, including all the headers and the L7 payload, leaving the application responsible for parsing and interpreting all of it.\nUsing standard sockets for goMESA would be problematic:\nConflict: Binding to UDP port 123 would conflict with the system\u0026rsquo;s legitimate NTP service. Indiscriminate Reception: Would receive all NTP traffic, requiring user-space filtering. Interference: Would likely disrupt normal time synchronization. Limited Access: Header information (like source IP from the IP layer) might be inaccessible or processed by the OS stack. Using libpcap allows the goMESA agent to:\nCoexist: Passively monitor traffic without binding the port. Precise Filtering: Capture only packets from the C2 server destined for the agent\u0026rsquo;s IP. Full Packet Access: Inspect all headers for verification and custom data extraction. Stealth: Operate alongside the legitimate NTP client. NEXT\n"},{"id":2,"href":"/goMESA/docs/architecture/","title":"Architecture","section":"Docs","content":" 3.1. Overview (Server \u0026amp; Agent) # goMESA follows a client-server model where multiple Agents connect back to a central C2 Server using NTP as the communication channel.\n3.2. Server Component # Responsibilities: Listens on UDP port 123, serves legitimate NTP requests, identifies and processes agent communications, manages agent state, queues and sends commands, receives and stores results. Database: Stores agent metadata (IP, OS, tags, status), command history, and outputs. Supports: SQLite: Default, file-based, portable, suitable for smaller deployments. MySQL: Client-server, suitable for larger deployments needing better concurrency and performance. Interface: Provides an interactive Terminal User Interface (TUI) built with Go\u0026rsquo;s BubbleTea library, offering a menu-driven experience for operators. OS Compatibility \u0026amp; Requirements: Written in Go, compiles cross-platform (Linux, macOS, Windows, BSD). Requires root/administrator privileges to bind to UDP port 123. Depends on libpcap/Npcap for network operations if running agent-like functions, though primarily needs port access. 3.3. Agent Component # Responsibilities: Establishes covert communication, mimics a legitimate NTP client, listens for commands via packet capture, executes commands using the system shell, and returns results chunked within NTP packets. System Integration: Detects host OS (Windows, Linux, macOS), identifies network configuration, modifies system NTP settings to point to the C2 server (e.g., Windows Time service, /etc/ntp.conf). Packet Capture: Uses libpcap/Npcap via gopacket to passively sniff for NTP packets from the C2 server destined for its IP address, avoiding conflicts with the system\u0026rsquo;s network stack. Cross-Platform Compatibility: Tailored implementations for: Windows: Integrates with Windows Time service, uses cmd.exe. Linux: Modifies NTP config (e.g., ntp.conf, timesyncd.conf), uses /bin/sh. macOS: Modifies macOS time service settings, uses /bin/sh. Requires root/administrator privileges for installation and packet capture. 3.4. Communication Protocol # goMESA layers its C2 protocol over standard NTP.\n3.4.1. Packet Structure # +----------------+---------------+----------------+ | NTP Header | goMESA Header | Payload | | (Standard 48B) | (4 bytes) | (Variable) | +----------------+---------------+----------------+ NTP Header: A valid, standard NTP header ensures the packet appears legitimate. goMESA Header: A 4-byte identifier placed in a field normally ignored or used for authentication (often within the first optional extension field or appended data not strictly part of the 48B base header, depending on implementation details hinted at). This header indicates the packet type. Payload: Encrypted command or response data. Note: The exact placement of the goMESA header/payload relative to the 48-byte structure can vary but aims to be ignored by standard NTP implementations.\n3.4.2. Packet Types # The 4-byte goMESA header signifies the purpose:\nPING: Agent heartbeat/check-in. COMU: Command chunk (part of a larger command, Unfinished). COMD: Command chunk (final part of a command, Done). COMO: Command Output chunk. KILL: Agent termination signal. 3.4.3. Command Encoding \u0026amp; Chunking # Commands and large outputs are broken into smaller chunks to fit within reasonable packet sizes. Each chunk is sent in a separate NTP-like packet, marked with the appropriate header (COMU, COMD, COMO). The receiving end reassembles these chunks based on sequence and the final COMD marker.\n3.4.4. Encryption (XOR, AES-256-GCM) # Payloads are encrypted for obfuscation and security:\nXOR: Simple, fast obfuscation using a fixed key. Easily reversible if the key is known but prevents casual inspection. AES-256-GCM: Stronger, authenticated encryption. Requires a shared key and proper nonce management to prevent replay attacks. 3.4.5. Handshaking # The initial PING packet sent by a new agent acts as a registration/handshake, allowing the server to add the agent to its database. Subsequent PINGs serve as heartbeats.\n"}]