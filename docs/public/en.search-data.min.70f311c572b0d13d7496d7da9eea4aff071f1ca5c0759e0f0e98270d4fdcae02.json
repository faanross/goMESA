[{"id":0,"href":"/goMESA/docs/introduction/","title":"Introduction","section":"Docs","content":" 1.1. Overview # goMESA is an educational Command and Control (C2) framework designed to demonstrate how legitimate network protocols can be repurposed for covert communications. Specifically, it utilizes the Network Time Protocol (NTP) as its transport mechanism, embedding command and control traffic within seemingly normal time synchronization packets.\nIt is based on mesa, with the following notable changes:\nEntire application is rewritten in Golang + integration of concurrency SQLite instead of MySQL as a simpler option Vue.js Web Client UI Docker support AES-256-GCM as a more secure encryption method Comprehensive documentation 1.2. Core Components # goMESA consists of three main components:\nC2 Server: Runs on an operator-controlled system. It acts as a fully functional NTP server (responding to legitimate time requests) while also listening for and managing connections from goMESA agents. It provides an interface for the operator to interact with agents and stores agent information and command history in a database. Agent: Runs on target systems (Windows, Linux, macOS). It mimics a standard NTP client, configuring the host system to use the C2 server for time synchronization. Covertly, it uses this NTP communication channel to receive commands, execute them, and send back results. Client UI: A Vue.js client establishes a persistent WebSocket connection to the goMESA server (or a dedicated web API layer), allowing for real-time, bidirectional communication. By operating under the guise of essential NTP traffic, goMESA aims to evade detection by network security monitoring tools that may not closely inspect UDP port 123 traffic.\n1.3. Features # NTP-Based Covert Channel: Uses UDP port 123 for all C2 communications. Functional NTP Server: The C2 server provides legitimate time synchronization, enhancing plausible deniability. Cross-Platform Agents: Supports Windows, Linux, and macOS target systems. Database Backend: Supports SQLite (default, portable). Agent Grouping: Manage agents efficiently by OS or custom service tags. Encryption: Offers basic XOR obfuscation and stronger AES-256-GCM encryption for payloads. Packet-Level Operations: Utilizes raw packet capture (libpcap/gopacket) for stealthy agent operation. Containerization Support: Docker and Docker Compose files available for easier deployment. NEXT\n"},{"id":1,"href":"/goMESA/docs/theory_concepts/","title":"Theory and Concepts","section":"Docs","content":" 2.1. NTP as a Covert Channel # NTP as transport protocol leverages several characteristics that make it interesting for covert communication.\n2.1.1. Why NTP Works # Ubiquity \u0026amp; Necessity: NTP is a fundamental internet protocol required by nearly all systems for time synchronization. It\u0026rsquo;s essential for logging, security mechanisms (like Kerberos), financial transactions, and more. Default Firewall Allowance: Due to its necessity, NTP traffic (UDP port 123) is almost universally permitted through firewalls. Limited Inspection: Unlike HTTP/S or DNS, NTP traffic is rarely subjected to deep packet inspection or significant scrutiny by security appliances. UDP Protocol: Being UDP-based, NTP is connectionless, simplifying the process of crafting and injecting custom packets without session establishment overhead. Regular Timing Patterns: Legitimate NTP clients communicate periodically, making the regular beaconing of C2 agents appear less suspicious than protocols with constant connections. Bidirectional Nature: The standard request-response pattern of NTP naturally facilitates two-way C2 communication. 2.1.2. Legitimate Cover \u0026amp; Plausible Deniability # A key aspect of goMESA\u0026rsquo;s design is that the C2 server functions as a real NTP server. It correctly processes and responds to time requests from standard NTP clients. This dual functionality provides plausible deniability; even if the server\u0026rsquo;s traffic is inspected, it appears to be legitimately serving time. The C2 communications are hidden within what looks like standard protocol interactions.\n2.2. Background on NTP # Understanding NTP\u0026rsquo;s normal operation highlights how goMESA exploits it.\n2.2.1. The Foundation of Internet Timekeeping # Developed by David Mills in 1985, NTP synchronizes clocks across computer networks. It uses a hierarchical system of \u0026ldquo;strata,\u0026rdquo; where Stratum 0 are high-precision sources (atomic clocks, GPS), Stratum 1 servers sync directly to Stratum 0, and so on. Most devices sync to servers several strata removed.\n2.2.2. Protocol Characteristics (UDP, Port 123) # NTP operates at the Application Layer but uses UDP (typically port 123) as its transport protocol. UDP\u0026rsquo;s connectionless nature is suitable for time synchronization where timeliness is valued over guaranteed delivery.\n2.2.3. Packet Structure \u0026amp; Timestamps # A standard NTP packet is 48 bytes long. Key fields include:\nLeap Indicator, Version Number, Mode (Client/Server/etc.) Stratum level Poll Interval, Precision Root Delay, Root Dispersion Reference ID Four 64-bit timestamps (Reference, Originate, Receive, Transmit) used for calculating clock offset and round-trip delay. 2.2.4. Operational Patterns # Clients poll servers periodically. The interval is adaptive, often starting frequently (e.g., 64s) and increasing (e.g., 1024s) as the clock stabilizes. Clients use the four timestamps in the request/response cycle to calculate offset and delay, gradually \u0026ldquo;slewing\u0026rdquo; their clock to match the server\u0026rsquo;s time, avoiding disruptive jumps.\n2.3. Raw Network Access Concepts (libpcap/gopacket) # goMESA agents use raw network access for stealth and control, typically via libraries like libpcap (or its Windows equivalent Npcap) accessed through Go bindings like gopacket.\n2.3.1. Introduction to Packet Capture # Standard applications use high-level socket APIs. Packet capture libraries bypass these, tapping directly into the network interface data stream (typically at the Data Link Layer). This provides access to complete, unmodified network packets, including all headers.\n2.3.2. Technical Foundation (Architecture, Filtering) # libpcap uses kernel-level mechanisms (e.g., BPF, AF_PACKET) to intercept packet copies. Crucially, it allows efficient kernel-level filtering (using BPF syntax like \u0026quot;udp and port 123\u0026quot;) so only relevant packets are passed to the user-space application, minimizing overhead. Captured packets are buffered in the kernel before being delivered to the application via the libpcap API.\n2.3.3. Benefits and Limitations # Benefits: Complete visibility, protocol independence, passive observation, custom packet crafting (injection), cross-platform API. Limitations: Requires root/admin privileges, performance overhead (kernel-user copy), complexity (protocol knowledge needed), potential for packet loss under heavy load, security implications of raw access. 2.3.4. Comparison to Standard Socket Programming # When a typical application uses sockets (like TCP or UDP sockets), it interacts primarily at the Transport Layer (L4) or slightly above. The operating system\u0026rsquo;s networking stack handles the processing for Layers 2 (Data Link), 3 (Network), and 4 (Transport). It strips away the headers from these lower layers and delivers only the application-level payload (Layer 7 data) to the application via the socket interface. Packet capture bypasses the operating system\u0026rsquo;s standard processing path that would normally handle layers 2, 3, and 4 and deliver only the L7 payload to an application via a socket. Instead, it gives the capturing application the raw data much lower down the stack, including all the headers and the L7 payload, leaving the application responsible for parsing and interpreting all of it.\nUsing standard sockets for goMESA would be problematic:\nConflict: Binding to UDP port 123 would conflict with the system\u0026rsquo;s legitimate NTP service. Indiscriminate Reception: Would receive all NTP traffic, requiring user-space filtering. Interference: Would likely disrupt normal time synchronization. Limited Access: Header information (like source IP from the IP layer) might be inaccessible or processed by the OS stack. Using libpcap allows the goMESA agent to:\nCoexist: Passively monitor traffic without binding the port. Precise Filtering: Capture only packets from the C2 server destined for the agent\u0026rsquo;s IP. Full Packet Access: Inspect all headers for verification and custom data extraction. Stealth: Operate alongside the legitimate NTP client. "}]